\include{settings}

\begin{document}

\include{titlepage}

\clearpage
\setcounter{page}{2}

\tableofcontents
\newpage

\addsec{\hfil\textnormal{ВВЕДЕНИЕ}}

В 1859 году ирландский математик, Уильям Гамильтон, предложил игру-головоломку:
Первый игрок отмечает в додекаэдре путь из пяти идущих друг за другом вершин, а второй игрок должен дополнить этот путь до простого цикла, проходящего
через все вершины додекаэдра [1].

Гамильтоновым путём называется простой путь, приходящий через каждую вершину графа ровно один раз.
Гамильтоновым циклом называют замкнутый гамильтонов путь.
Граф называется гамильтоновым, если он содержит гамильтонов цикл.

Таким образом, в гамильтоновом графе можно обойти все вершины по рёбрам и вернуться в начальную точку, причём каждая вершина (кроме начальной) будет пройдена ровно один раз.

Задача поиска гамильтонова цикла относится к классу NP-полных задач и известно лишь несколько необходимых и несколько достаточных условий существования гамильтоновых циклов.

Рассмотрим задачу о коммивояжёре.
Задача о коммивояжере — задача, в которой коммивояжер должен посетить N городов, побывав в каждом из них ровно по одному разу и завершив путешествие в том городе, с которого он начал.
В какой последовательности ему нужно обходить города, чтобы общая длина его пути была наименьшей?

Например, надо найти оптимальный марщрут по городам Европы (причем путешествие должно закончиться в том же городе, с которого начали, то есть вернуться домой).

Целью работы является:

\begin{enumerate}

    \item Исследовать алгоритмы поиска гамильтонова цикла.

    \item Написать программу, которая реализовывает алгоритм поиска в условиях теорем Дирака и Оре.

    \item Написать программу, которая реализовывает рекурсивный алгоритм.

    \item С помощью написанных программ оценить трудоемкость алгоритмов и сравнить их на различных входных данных

\end{enumerate}

\newpage

\section{Описание задачи}

\subsection{Математическая формализация задачи}
Необходимо найти путь на графе, который удовлетворяет определению гамильтонова пути.
На вход подается граф, в котором нужно найти гамильтонов путь.
Выход: гамильтонов путь или информацию о его отсутствии.

\subsection{Описание АТД и его операторов}
На вход каждому алгоритму подается неориентированный граф, который представлен в виде матрицы смежности.

Оператор $\operatorname{is\_connected}$ возвращает булево значение, которое показывает, есть ли ребро между двумя вершинами.

Оператор $\operatorname{get\_full}$ возвращает граф, в котором между каждой вершиной есть ребро.

\lstinputlisting[language=Python]{../src/main/graph_adjacency_matrix.py}

\newpage

\section{Алгоритм нахождения Гамильтонова цикла в условиях теорем Дирака и Оре}

\subsection{Теорема Оре}
Если n $\geq$ 3 и $\operatorname{deg}$ u + $\operatorname{deg}$ v $\geq$ n для любых двух различных несмежных вершин u и v неориентированного графа  G, то  G — гамильтонов граф [2].

{Доказательство (от противного):}
Пусть $\exists$ граф G, который удовлетворяет условию теоремы, но не является гамильтоновым графом.
Будем добавлять к нему новые ребра до тех пор, пока не получим максимальный негамильтонов граф G'.
Так как мы только добавляли ребра, условие теоремы не нарушилось.

Пусть u и v - несмежные вершины в полученном графе G'.
Если добавить ребро uv, то появится гамильтонов цикл. Тогда путь (u,v) — гамильтонов.
Для вершин u и v выполнено $\operatorname{deg}$ u + $\operatorname{deg}$ v $\geqslant$ n.


По принципу Дирихле всегда найдутся две смежные вершины $t_1$, $t_2$ на пути (u, v),
т.е. u $\dots$ $t_1$$t_2$ $\dots$ v , такие, что существует ребро u$t_2$ и ребро $t_1$v.

Действительно, пусть S =  $\{$ i $\mid$ $e_i$ = u$t_{i+1}$ $\in$ EG $\}$
и T = $\{$ i $\mid$ $f_i$ = $t_i$v $\in$ EG $\}$

Имеем: $\left\vert S \right\vert + \left\vert T \right\vert = \operatorname{deg} u + \operatorname{deg} v \geqslant n,$ но $\left\vert S + T \right\vert < n.
Тогда \left\vert S\cap T \right\vert = \left\vert S \right\vert + \left\vert T \right\vert - \left\vert S+T \right\vert > 0,$
т. е. $\exists$ i: u$t_{i+1} \in$ EG и $t_iv \in EG.$

Тогда $\left\vert S \cap T \right\vert = \left\vert S \right\vert + \left\vert T \right\vert - \left\vert S + T \right\vert > 0$, т. е.
$\exists i: ut_{i+1}\in EG$ и $t_iv \in EG.$
Получили противоречие, т. к. u $\dots t_1v \dots t_2u$ — гамильтонов цикл.

\subsection{Теорема Дирака}
Пусть G — неориентированный граф и $\delta$ — минимальная степень его вершин.
Если n $\geq$ 3 и $\delta\geq{n\over{2}}$, то  G — гамильтонов граф.

{Доказательство:}
Рассмотрим красивое и простое доказательство. А именно вывод из теоремы Оре.
Возьмем любые неравные вершины u, v $\in$ G. Тогда deg u + deg v $\geqslant \frac{n}{2}$ + $\frac{n}{2}$ = n.
По теореме Оре G — гамильтонов граф.

\subsection{Неформальное описание алгоритма}
Если дан граф G = $\langle {V, E} \rangle$, который удовлетворяет условию теоремы Дирака или Оре,
то в нем можно найти гамильтонов цикл.

Поступим следующим образом: заведем очередь и положим в нее все вершины нашего графа (не важно в каком порядке).
Пусть n = |V|. Тогда n(n -1) раз будем делать следующую операцию:
\begin{itemize}

    \item Пусть $v_1$ — это голова очереди, $v_2$ — следующая за ней вершина и так далее.
    Если между первой и второй вершиной в очереди есть ребро в графе G, то перемещаем первую вершину в конец очереди и переходим к следующей итерации.

    \item Если между первой и второй вершиной в очереди ребра нет, то найдем вершину $v_i$, где i > 2, такую что, ребра $v_1$$v_i$, $v_2$$v_{i+1}$ $\in$ E (так как у нас для графа выполнена либо теорема Оре, либо теорема Дирака, то такая вершина обязательно найдется; чуть позже докажем это явно).
    После чего поменяем в очереди местами вершины $v_2$ и $v_i$, $v_3$ и $v_{i-1}$, $v_{2+j}$ и $v_{i-j}$, и так далее, пока 2 + j < i - j (то есть j пробегает все значения от 0 до значения заданного неравенством).
    Теперь у нас появилось ребро между первой и второй вершинами в очереди (теперь вторая вершина, это та, которая была до разворота на i-й позиции), а также, гарантированно существует ребро между i-й и (i+1)-й вершинами очереди.
    После этого, так же как и в первом случае, оправляем первую вершину в конец очереди.

\end{itemize}

Таким образом после n итераций, мы получаем последовательность (вершины лежащие в очереди), где любые 2 соседние вершины соединены ребром, все вершины графа находятся в этой последовательности, и более того, каждая ровно один раз, а также существует ребро между последней и первой вершинами очереди, а это и значит, что мы решили поставленную задачу.

\subsection{Доказательство алгоритма}

\subsubsection{Лемма о поиске вершины}
Каждый раз, когда нам надо искать вершину $v_i$, где i > 2, такую что $v_1$$v_i$, $v_2$$v_{i+1}$ $\in$ E, такая вершина действительно существует.

{Доказательство:}

Рассмотрим множество S = \{i $\mid$ $v_1$$v_i$ $\in$ E\}, состоящее из индексов вершин, смежных с $v_1$, и множество T = \{i+1 $\mid$ $v_2$$v_{i+1}$ $\in$ E\}, индексов вершин смежных с $v_2$.

Заметим, что S $\subset$ \{3, 4, $\ldots$, n\}, а T $\subset$ \{2, 3, $\ldots$, n - 1\}, тогда S $\cup$ T $\subset$ \{2, 3, $\ldots$, n\},
а значит $\left\vert S \cup T \right\vert \leqslant$ n-1, в то же время $\left\vert S \right\vert + \left\vert T \right\vert$ = $\operatorname{deg}$ $v_1$ + $\operatorname{deg}$ $v_2$ $\geqslant$ n (по условию теоремы Оре или теоремы Дирака).

Из этого следует, что S $\cap T \ne \varnothing$, а это и значит, что искомая вершина существует.

\subsubsection{Лемма о существовании рабра и теорема о корректности}
{Лемма о существовании:}
После n(n - 1) итераций между каждой парой соседних вершин очереди существует ребро.

{Доказательство:}

Достаточно заметить, что каждую итерацию алгоритма, мы, в случае отсутствия ребра, между $v_1$ и $v_2$ увеличиваем количество пар соседних в очереди вершин, между которыми есть ребро,
как минимум на 1 (это прямое следствие условия поиска нужной вершины, в случае отсутствия ребра), для поиска такой пары требуется не более n итераций.

Таких пар изначально не более n, откуда следует, что после n итераций, второе условие будет выполнено.
Что и требовалось доказать.

{Теорема о корректности:}
Алгоритм находит гамильтонов цикл.

{Доказательство:}

Из предыдущих лемм следует корректность алгоритма.

\subsection{Формальное описание алгоритма: псевдокод}
Приведу формальное описание алгоритма поиска гамильтонова цикла в условиях теорем Оре и Дирака.
Ранее было приведено неформальное описание алгоритма.

\begin{algorithmic}[1]
\Procedure{Ore Dirac}{$\langle$ V, E $\rangle$}

\For{v $\in$ V}
\State queue.pushBack(v)
\EndFor

\For{k = 0 .. n * (n - 1)}

\If {(queue.at(0), queue.at(1)) $\notin$ E}
    \State i = 2
    \State  \While{(queue.at(0), queue.at(i)) $\notin$ E or (queue.at(1), queue.at(i + 1)) $\notin$ E}
            \State i++
            \EndWhile
    \State queue.swapSubQueue(1, i)
\EndIf

queue.pushBack(queue.top())

queue.pop()
\EndFor
\EndProcedure
\end{algorithmic}

\subsection{Программная реализация}
Программа была написана на языке программирования Python 3.6.0 в среде разработки PyCharm.
Также были реализованы следующие функции:
\begin{itemize}

    \item Функция $\operatorname{is\_ore}$ проверяет, удовлетворяет ли граф теореме Оре.
    \item Функция $\operatorname{is\_dirac}$ проверяет, удовлетворяет ли граф теореме Дирака.

\end{itemize}

Исходный код программы можно найти в Приложении 3.

\subsection{Результаты тестирования}
Для проверки работоспособности алгоритма, был написан unit-тест.
Все тесты прошли успешно.

Исходный код unit-теста можно найти в Приложении 1.

\subsection{Выводы о вычислительной сложности на основе тестирования}
%Поиск вершины, удовлетворяющей заданному условию работает за O(n),
%а таких поисков будет осуществлено не более чем n. Оставшиеся n(n - 2) итерации выполняются за O(1).
%Тогда алгоритм выполняется за O$(n^2)$.
Проведем оценку алгоритма.
\begin{enumerate}
    \item Данный участок будет выполняться за O(n).
    \begin{algorithmic}
        \For{v $\in$ V}
            \State queue.pushBack(v)
        \EndFor
    \end{algorithmic}

    \item Данный участок будет выполняться за O(n).
    \begin{algorithmic}
        \While{(queue.at(0), queue.at(i)) $\notin$ E or (queue.at(1), queue.at(i + 1)) $\notin$ E}
            \State i++
        \EndWhile
    \end{algorithmic}

    \item Данный участок будет выполняться за O$(n^3)$. Так как цикл будет O$(n^2)$ и вложенный цикл из предыдущего пункта O(n).
    \begin{algorithmic}
        \For{k = 0 .. n * (n - 1)}

            \If {(queue.at(0), queue.at(1)) $\notin$ E}
                \State i = 2
                \State  \While{(queue.at(0), queue.at(i)) $\notin$ E or (queue.at(1), queue.at(i + 1)) $\notin$ E}
                        \State i++
                        \EndWhile
                \State queue.swapSubQueue(1, i)
            \EndIf

            queue.pushBack(queue.top())

            queue.pop()
        \EndFor
    \end{algorithmic}

    \item Следовательно, сложность алгоритма O$(n^3)$

\end{enumerate}

\newpage

\section{Рекурсивный алгоритм}

\subsection{Неформальное описание алгоритма, краткое обоснование}

Во многом этот алгоритм напоминает алгоритм поиска в глубину, но главное его отличие заключается в том, что если из какой-то вершины не удается продолжить путь дальше (то есть были рассмотрены все ребра и все возможные продолжения привели в тупик), то алгоритм возвращается в предыдущую вершину, при этом покинутая вершина «перекрашивается», то есть с нее снимается отметка о том, что эта вершина была посещена ранее.
При этом алгоритм может вернуться в эту вершину еще раз, уже по другому пути (и даже обязан это сделать, если в графе существует гамильтонов путь, так как гамильтонов путь проходит через все вершины).

Пусть n - число вершин в графе, вершины пронумерованы числами от 0 до n - 1.
Граф задан матрицей смежности A.
В path будет храниться список вершин, входящих в путь.
Функция $\operatorname{recursive}$ принимает в качестве параметра номер вершины, добавляемой к пути и возвращает значение true, если удалось построить гамильтонов путь и false, если не удалось.
Причем если путь построить удалось, то построенный путь будет храниться в списке path.

\subsection{Формальное описание алгоритма: псевдокод}
Приведу формальное описание рекурсивного алгоритма поиска гамилmтонова цикла.
Ранее было приведено неформальное описание алгоритма.

\begin{algorithmic}[1]
\Procedure{Recursive}{curr}
    \State path.append(curr)
    \If{length(path) == n}
        \If {A[path[0]][path[-1]] == 1}
                \State {return true}
        \Else
            \State path.pop()
            \State return false
        \EndIf
    \EndIf
    \State Visited[curr] = True

    \For {next = 0 .. n - 1}
        \If {A[curr][next] == 1 and not visited[next]}
            \If {recursive(next)}
                \State return true
            \EndIf
        \EndIf
    \EndFor
    \State visited[curr] = false
    \State path.pop()

    \State return false
\EndProcedure
\end{algorithmic}

\subsection{Программная реализация}
Программа была написана на языке программирования Python 3.6.0 в среде разработки PyCharm.

Исходный код программы можно найти в Приложении 4.

\subsection{Результаты тестирования}
Для проверки работоспособности алгоритма, был написан unit-тест.
Все тесты прошли успешно.

Исходный код unit-теста можно найти в Приложении 2.

\subsection{Выводы о вычислительной сложности на основе тестирования}
Рекурсивный поиск гамильтонова цикла может потребовать экспоненциального времени.
Рассмотрим граф, у которого одна вершина изолирована, а ребра, связывающие остальные $|V| - 1$ вершин, образуют полный граф.
Функция $\operatorname{recursive}$ никогда не найдет гамильтонова цикла, но она исследует все $(|V| - 2)!$ путей, начинающихся в выбранной начальной вершине, каждый из которых использует $|V| - 1$ рекурсивных вызовов.
Следовательно, общее число рекурсивных вызовов равно $(V - 1)!$.

\newpage

\section{Сравнение алгоритмов}
Построим графики, на которых отразим зависимость времени выполнения от размера входного графа.
Все замеры проведены с помощью line\_profiler.

\subsection{Графы, между каждой вершиной которых существует ребро}
Сравним время выполнения алгоритмов на графах, между каждой вершиной которых существует ребро.

Очевидно, что это наилучший случай для обоих алгоритмов.
Так как рекурсивный алгоритм по принципу схож с алгоритмом поиска в гллубину, то он просто всегда идет вглубь.
Получается, что в данном случае рекурсивный алгоритм выполняется за линейное время.
\\[0.5cm]

\begin{tikzpicture}
\begin{axis}[
	xlabel = {Количество вершин},
	ylabel = {Время выполнения, сек.},
    legend pos = north west,
    width = 15cm,
    grid = major
]

\legend{
	$Recursive$,
	$Ore Dirac$
};
% Recursive
\addplot table [x = n, y = sec] {
	n           sec
	10          0.000456
	100         0.02701
	200         0.089182
	400         0.334946
	500         0.53253
	600         0.736005
};
% Ore Dirac
\addplot table [x = n, y = sec] {
	n           sec
	10          0.000817
	100         0.065724
	200         0.245786
	400         0.93315
	500         1.55939
	600         2.20084
};

\end{axis}
\end{tikzpicture}
\captionof{figure}{Графы, между каждой вершиной которых существует ребро.}

\subsection{Графы, удовлетворяющие теореме Оре или Дирака}
Проведем сравнение алгоримтов на графах, которые заранее удовлетворяют теореме Дирака или Оре.
Нам не нужно заранее проверять, удовлетворяет ли граф теореме Оре или Дирака.

Как видно из графиков, рекурсивный алгоритм опять выигрывает.

Дело в том, что алгоритм поиска гамильтонова цикла в условиях теорем Дирика или Оре работает только на графах, которые удовлетворяют этим теоремам.
А на этих входных данных рекурсивнй алгоритм алгоритм также работает быстрее.
\\[0.5cm]

\begin{tikzpicture}
\begin{axis}[
	xlabel = {Количество вершин},
	ylabel = {Время выполнения, сек.},
    legend pos = north west,
    width = 15cm,
    grid = major
]

\legend{
	$Recursive$,
	$Ore Dirac$
};
% Recursive
\addplot table [x = n, y = sec] {
	n           sec
	10          0.000708
	100         0.022036
	200         0.082393
	300         0.18306
	400         0.370803
};
% Ore Dirac
\addplot table [x = n, y = sec] {
	n           sec
	10          0.000651
	100         0.057947
	200         0.272056
	300         0.504871
	400         0.968038
};

\end{axis}
\end{tikzpicture}
\captionof{figure}{Графы, удовлетворяющие теоремам Оре и Дирака.}

\newpage

\addsec{\hfil\textnormal{Заключение}}

В ходе работы были рассмотрена алгоритмы поиска гамильтонова цикла: рекурсивный алгоритм и алгоритм в условиях теорем Оре и Дирака.
Каждый алгоритм был реализован на языке программирования Python 3.6.0 и покрыт unit-тестами.

Было проведено сравнение времени выполнения алгоритмов, приведены графики, а также обоснованы результаты.

\newpage

\addsec{\hfil\textnormal{Список использованных источников}}

\begin{enumerate}

    \item Алгоритмы: построение и анализ, 3-е издание / Томас Х. Кормен, Чарльз И. Лейзерсон, Рональд Л. Ривест, Клиффорд Штайн.

    \item Алгоритм нахождения Гамильтонова цикла в условиях теорем Дирака и Оре:
    [Электронный документ].
    - (https://neerc.ifmo.ru/wiki/index.php?title=Алгоритм\_нахождения\-\_Гамильтонова\_цикла\_в\_условиях\_теорем\_Дирака\_и\_Оре).
    Проверено 31.05.2017.

\end{enumerate}

\newpage

\addsec{\hfil\textnormal{ПРИЛОЖЕНИЕ 1}}
{\bf {\hfil{Unit-тест для алгоритма в условиях теорем Оре и Дирака}}}\\[0.3cm]
\lstinputlisting[language=Python]{../src/test/test_ore_dirac.py}

\newpage

\addsec{\hfil\textnormal{ПРИЛОЖЕНИЕ 2}}
{\hfil \bf {{Unit-тест для рекурсивного алгоритма}}}\\[0.3cm]
\lstinputlisting[language=Python]{../src/test/test_recursive.py}

\newpage

\addsec{\hfil\textnormal{ПРИЛОЖЕНИЕ 3}}
{\bf {\hfil{Программная реализация алгоритма в условиях теорем Оре и Дирака}}}\\[0.3cm]
\lstinputlisting[language=Python]{../src/main/ore_dirac.py}

\newpage

\addsec{\hfil\textnormal{ПРИЛОЖЕНИЕ 4}}
{\bf {\hfil{Программная реализация рекурсивного алгоритма}\hfil}}\\[0.3cm]
\lstinputlisting[language=Python]{../src/main/recursive.py}

\newpage

\end{document}