\include{settings}

\begin{document}

\include{titlepage}

\tableofcontents
\newpage

\section{Постановка задачи}

\subsection{История}
В 1859 году ирландский математик, Уильям Гамильтон, предложил игру-головоломку:
Первый игрок отмечает в додекаэдре путь из пяти идущих друг за другом вершин, а второй игрок должен дополнить этот путь до простого цикла, проходящего
через все вершины додекаэдра.

\subsection{Основные определения}
{\bf Гамильтоновым путём} называется простой путь, приходящий через каждую вершину графа ровно один раз.
{\bf Гамильтоновым циклом} называют замкнутый гамильтонов путь.
Граф называется {\bf гамильтоновым}, если он содержит гамильтонов цикл.

Таким образом, в гамильтоновом графе можно обойти все вершины по рёбрам и вернуться в начальную точку, причём каждая вершина (кроме начальной) будет пройдена ровно один раз.

Задача поиска гамильтонова цикла относится к классу NP-полных задач и известно лишь несколько необходимых и несколько достаточных условий существования гамильтоновых циклов.

\section{Практическая значимость задачи}
Обобщим задачу поиска гамильтонова цикла на задачу о коммивояжёре.

{\bf Задача о коммивояжере} — задача, в которой коммивояжер должен посетить N городов, побывав в каждом из них ровно по одному разу и завершив путешествие в том городе, с которого он начал.
В какой последовательности ему нужно обходить города, чтобы общая длина его пути была наименьшей?

Например, надо найти оптимальный марщрут по городам Европы (причем путешествие должно закончиться в том же городе, с которого начали, то есть вернуться домой).

\section{Математическая модель задачи}

\subsection{Математическая формализация задачи}
Необходимо найти путь на графе, который удовлетворяет определению гамильтонова пути.
На вход подается граф, в котором нужно найти гамильтонов путь.
Выход: гамильтонов путь или информацию о его отсутствии.

\subsection{Модель данных}
Представления графа в виде матрицы смежности.
\lstinputlisting[language=Python]{../src/main/graph_adjacency_matrix.py}


\section{Алгоритм нахождения Гамильтонова цикла в условиях теорем Дирака и Оре}

\subsection{Теорема Оре}
Если n $\geq$ 3 и deg u + deg v $\geq$ n для любых двух различных несмежных вершин u и v неориентированного графа  G, то  G — гамильтонов граф.

\subsection{Теорема Дирака}
Пусть G — неориентированный граф и $\delta$ — минимальная степень его вершин.
Если n $\geq$ 3 и $\delta\geq{n\over{2}}$, то  G — гамильтонов граф.

\subsection{Неформальное описание алгоритма, краткое обоснование}
Если дан граф G = $\langle {V, E} \rangle$, который удовлетворяет условию теоремы Дирака или Оре,
то в нем можно найти гамильтонов цикл.

Каждый раз, когда нам надо искать вершину $v_i$, где i > 2, такую что $v_{1}v_{i}$, $v_{2}v_{i+1}$ $\in$ E, такая вершина действительно существует.

После $n(n - 1)$ итераций между каждой парой соседних вершин очереди существует ребро.

\subsection{Описание выбранного АТД}
\subsubsection{Выбранные структура и тип данных}
Матрица смежнсти вершин.
\subsubsection{Операторы АТД}
Метод, который позволяет узнать, есть ли в между двумя веришнами ребро.

\subsection{Формальное описание алгоритма: псевдокод}
\begin{algorithmic}[1]
\Procedure{Ore Dirac}{$\langle$ V, E $\rangle$}

\For{v $\in$ V}
\State queue.pushBack(v)
\EndFor

\For{k = 0 .. n * (n - 1)}

\If {(queue.at(0), queue.at(1)) $\notin$ E}
    \State i = 2
    \State  \While{(queue.at(0), queue.at(i)) $\notin$ E or (queue.at(1), queue.at(i + 1)) $\notin$ E}
            \State i++
            \EndWhile
    \State queue.swapSubQueue(1, i)
\EndIf
queue.pushBack(queue.top())
queue.pop()
\EndFor
\EndProcedure
\end{algorithmic}

\subsection{Программная реализация}
\lstinputlisting[language=Python]{../src/main/ore_dirac.py}

\subsection{Результаты тестирования}

\subsection{Выводы о вычислительной сложности на основе тестирования}
Поиск вершины, удовлетворяющей заданному условию работает за O(n), а таких поисков будет осуществлено не более чем n. Оставшиеся n(n - 2) итерации выполняются за O(1). Тогда алгоритм выполняется за O$(n^2)$.

\section{Рекурсивный алгоритм}

\subsection{Неформальное описание алгоритма, краткое обоснование}

\subsection{Описание выбранного АТД}
\subsubsection{Выбранные структура и тип данных}
Матрица смежнсти вершин.
\subsubsection{Операторы АТД}
Метод, который позволяет узнать, есть ли в между двумя веришнами ребро.

\subsection{Формальное описание алгоритма: псевдокод}
\begin{algorithmic}[1]
\Procedure{Recursive}{curr}
\EndProcedure
\end{algorithmic}

\subsection{Программная реализация}
\lstinputlisting[language=Python]{../src/main/recursive.py}

\subsection{Результаты тестирования}



\end{document}